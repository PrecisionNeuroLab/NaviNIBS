from __future__ import annotations
import attrs
import logging
import nibabel as nib
import nitransforms as nit
import numpy as np
import os
import pickle
import typing as tp
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from NaviNIBS.Navigator.Model.Session import Session
from NaviNIBS.Navigator.Model.HeadModel import MshVersion
from NaviNIBS.util.attrs import attrsAsDict
from NaviNIBS.util.Signaler import Signal
from NaviNIBS.util.Transforms import applyTransform, invertTransform

from NaviNIBS.Navigator.Model.GenericCollection import GenericCollection, GenericCollectionDictItem

logger = logging.getLogger(__name__)


@attrs.define
class CoordinateSystem(GenericCollectionDictItem[str]):
    _description: str = ''
    _isVisible: bool = True
    _isAutogenerated: bool = False
    _session: tp.Optional[Session] = attrs.field(default=None, repr=False)

    def __attrs_post_init__(self):
        super().__attrs_post_init__()

    @property
    def description(self):
        return self._description

    @property
    def session(self):
        return self._session

    @session.setter
    def session(self, newSes: tp.Optional[Session]):
        self.sigItemAboutToChange.emit(self._key)
        self._session = newSes
        self.sigItemChanged.emit(self._key)

    @property
    def isVisible(self):
        return self._isVisible

    @property
    def isAutogenerated(self):
        return self._isAutogenerated

    def transformFromWorldToThis(self, coords: np.ndarray) -> np.ndarray:
        raise NotImplementedError  # should be implemented by subclass

    def transformFromThisToWorld(self, coords: np.ndarray) -> np.ndarray:
        raise NotImplementedError  # should be implemented by subclass

    def asDict(self):
        return attrsAsDict(self, exclude=['session'])


@attrs.define(kw_only=True)
class AffineTransformedCoordinateSystem(CoordinateSystem):
    _transfThisToWorld: tp.Optional[np.ndarray] = None
    _transfWorldToThis: tp.Optional[np.ndarray] = None

    __transfWorldToThis: tp.Optional[np.ndarray] = attrs.field(init=False, default=None)
    __transfThisToWorld: tp.Optional[np.ndarray] = attrs.field(init=False, default=None)

    def __attrs_post_init__(self):
        super().__attrs_post_init__()
        self.sigItemChanged.connect(lambda *args, **kwargs: self.clearCache())

        assert (self._transfThisToWorld is None) != (self._transfWorldToThis is None),\
            'Must specify transfThisToWorld or transfWorldToThis'

    @property
    def transfThisToWorld(self):
        if self._transfThisToWorld is not None:
            return self._transfThisToWorld
        else:
            if self.__transfThisToWorld is None:
                self.__transfThisToWorld = invertTransform(self._transfWorldToThis)
            return self.__transfThisToWorld

    @property
    def transfWorldToThis(self):
        if self._transfWorldToThis is not None:
            return self._transfWorldToThis
        else:
            if self.__transfWorldToThis is None:
                self.__transfWorldToThis = invertTransform(self._transfThisToWorld)
            return self.__transfWorldToThis

    def clearCache(self):
        self.__transfThisToWorld = None
        self.__transfWorldToThis = None

    def transformFromWorldToThis(self, coords: np.ndarray) -> np.ndarray:
        return applyTransform(self.transfWorldToThis, coords, doCheck=False)

    def transformFromThisToWorld(self, coords: np.ndarray) -> np.ndarray:
        return applyTransform(self.transfThisToWorld, coords, doCheck=False)


T = tp.TypeVar('T')


# define an empty placeholder
class Invalid:
    pass

invalid = Invalid()

@attrs.define(kw_only=True)
class NonlinearTransformedCoordinateSystem(CoordinateSystem):
    _deformationFieldThisToWorld_filepath: str = None
    _deformationFieldWorldToThis_filepath: str = None

    _deformationFieldThisToWorld: nib.Nifti1Image | Invalid | None = attrs.field(init=False, default=None)
    _deformationFieldWorldToThis: nib.Nifti1Image | Invalid | None = attrs.field(init=False, default=None)

    _transfThisToWorld: nit.nonlinear.DenseFieldTransform | Invalid | None = attrs.field(init=False, default=None)
    _transfWorldToThis: nit.nonlinear.DenseFieldTransform | Invalid | None = attrs.field(init=False, default=None)

    _cachedValues: dict[bytes, tp.Any] = attrs.field(init=False, factory=dict, repr=False)

    def __attrs_post_init__(self):
        super().__attrs_post_init__()
        self.sigItemChanged.connect(lambda *args, **kwargs: self.clearCache())

    def _maybeFillNaNs(self, img: nib.Nifti1Image, maxPercent: float = 5, fillValue: float = 0.) -> nib.Nifti1Image | Invalid:
        data = img.get_fdata()
        numNaNs = np.sum(np.isnan(data))
        totalVoxels = np.prod(data.shape)
        percentNaNs = (numNaNs / totalVoxels) * 100.

        if percentNaNs > 0:
            if percentNaNs > maxPercent:
                # too many NaNs, don't fill
                logger.info(f'{percentNaNs:.2f}% values in deformation field are NaN, not filling.')
                return invalid
            else:
                logger.info(f'Only {percentNaNs:.2f}% values in deformation field are NaN, filling with {fillValue}.')
                # fill inline
                newData = data.copy()
                newData[np.isnan(newData)] = fillValue
                newImg = nib.Nifti1Image(newData, img.affine, img.header)
                return newImg

        return img

    @property
    def deformationFieldThisToWorld(self):
        if self._deformationFieldThisToWorld is None:
            logger.info(f'Loading deformation field from {self._deformationFieldThisToWorld_filepath}')
            self._deformationFieldThisToWorld = nib.load(self._deformationFieldThisToWorld_filepath)
            if np.any(np.isnan(self._deformationFieldThisToWorld.get_fdata())):
                logger.warning(f'Deformation field loaded from {self._deformationFieldThisToWorld_filepath} contains NaN values, which will will break nonlinear transform map.')
                self._deformationFieldThisToWorld = self._maybeFillNaNs(self._deformationFieldThisToWorld)
        return self._deformationFieldThisToWorld

    @property
    def deformationFieldWorldToThis(self):
        if self._deformationFieldWorldToThis is None:
            logger.info(f'Loading deformation field from {self._deformationFieldWorldToThis_filepath}')
            self._deformationFieldWorldToThis = nib.load(self._deformationFieldWorldToThis_filepath)
            if np.any(np.isnan(self._deformationFieldWorldToThis.get_fdata())):
                logger.warning(f'Deformation field loaded from {self._deformationFieldWorldToThis_filepath} contains NaN values, which will break nonlinear transform map.')
                self._deformationFieldWorldToThis = self._maybeFillNaNs(self._deformationFieldWorldToThis)

        return self._deformationFieldWorldToThis

    @property
    def transfThisToWorld(self):
        if self._transfThisToWorld is None:
            if self.deformationFieldThisToWorld is invalid:
                self._transfThisToWorld = invalid
            else:
                self._transfThisToWorld = nit.nonlinear.DenseFieldTransform(
                    field=self.deformationFieldThisToWorld,
                    is_deltas=False)  # TODO: determine whether also need to specify reference arg
        return self._transfThisToWorld

    @property
    def transfWorldToThis(self):
        if self._transfWorldToThis is None:
            if self.deformationFieldWorldToThis is invalid:
                self._transfWorldToThis = invalid
            else:
                self._transfWorldToThis = nit.nonlinear.DenseFieldTransform(
                    field=self.deformationFieldWorldToThis,
                    is_deltas=False,
                )  # TODO: determine whether also need to specify reference arg
        return self._transfWorldToThis

    def _cacheWrap(self, fn: tp.Callable[..., T], **kwargs) -> T:
        # noinspection PyUnresolvedReferences
        key = pickle.dumps((fn.__name__, kwargs))

        if key in self._cachedValues:
            return self._cachedValues[key]
        else:
            val = fn(doUseCache=False, **kwargs)
            self._cachedValues[key] = val
            return val

    def clearCache(self):
        self._deformationFieldThisToWorld = None
        self._deformationFieldWorldToThis = None
        self._transfThisToWorld = None
        self._transfWorldToThis = None
        self._cachedValues = dict()

    def transformFromWorldToThis(self, coords: np.ndarray, doUseCache: bool = True) -> np.ndarray:
        if doUseCache:
            return self._cacheWrap(self.transformFromWorldToThis, coords=coords)

        if coords.ndim == 1:
            coords = coords[np.newaxis, :]
            shouldCollapse = True
        else:
            shouldCollapse = False

        if self.transfWorldToThis is not invalid:
            res = self.transfWorldToThis.map(coords)
        else:
            # original field had some NaNs. If we try to transform, nitransforms will silently pass through untransformed coords
            # instead, return NaNs here
            res = np.full(coords.shape, np.nan, dtype=np.float64)

        if shouldCollapse:
            res = res.flatten()

        return res

    def transformFromThisToWorld(self, coords: np.ndarray, doUseCache: bool = True) -> np.ndarray:
        if doUseCache:
            return self._cacheWrap(self.transformFromThisToWorld, coords=coords)

        if coords.ndim == 1:
            coords = coords[np.newaxis, :]
            shouldCollapse = True
        else:
            shouldCollapse = False

        if self.transfThisToWorld is not invalid:
            res = self.transfThisToWorld.map(coords)
        else:
            # original field had some NaNs. If we try to transform, nitransforms will silently pass through untransformed coords
            # instead, return NaNs here
            res = np.full(coords.shape, np.nan, dtype=np.float64)

        if shouldCollapse:
            res = res.flatten()

        return res


@attrs.define
class CoordinateSystems(GenericCollection[str, CoordinateSystem]):
    _session: tp.Optional[Session] = attrs.field(default=None, repr=False)

    def __attrs_post_init__(self):
        super().__attrs_post_init__()

        if self.session is not None:
            self.session.headModel.sigFilepathChanged.connect(self.autogenerateCoordinateSystems)
            self.autogenerateCoordinateSystems()

    @property
    def session(self):
        return self._session

    @session.setter
    def session(self, newSes: tp.Optional[Session]):
        if self._session is newSes:
            return
        if self._session is not None:
            self.session.headModel.sigFilepathChanged.disconnect(self.autogenerateCoordinateSystems)
        self.setAttribForItems(self.keys(), dict(session=[newSes for key in self.keys()]))
        self._session = newSes
        if newSes is not None:
            newSes.headModel.sigFilepathChanged.connect(self.autogenerateCoordinateSystems)
        self.autogenerateCoordinateSystems()

    def autogenerateCoordinateSystems(self):
        if self.session is not None:
            if self.session.headModel.filepath is not None:
                # autogenerate from files generated by SimNIBS
                logger.info('Autogenerating coord system transforms from SimNIBS results')

                m2mDir = self.session.headModel.m2mDir

                inputPath = os.path.join(m2mDir, 'toMNI', 'MNI2conform_12DOF.txt')
                if os.path.exists(inputPath):
                    with open(inputPath, 'r') as f:
                        MNIToMRITransf = np.loadtxt(f)

                    coordSys = AffineTransformedCoordinateSystem(
                        key='MNI_SimNIBS12DoF',
                        description='SimNIBS-generated 12DoF MNI transform',
                        transfThisToWorld=MNIToMRITransf,
                        isAutogenerated=True
                    )
                    if coordSys.key in self._items:
                        assert self._items[coordSys.key].isAutogenerated
                    self.setItem(coordSys)
                else:
                    if self.session.headModel.mshVersion == MshVersion.HEADRECO:
                        logger.error(f'Did not find expected input file at {inputPath}')
                    else:
                        logger.info(f'No SimNIBS-generated 12DoF MNI transform found at {inputPath}, ')

                if True:
                    # prefer .nii.gz, fall back to .nii for both MNI2Conform and Conform2MNI
                    base_toConform = os.path.join(m2mDir, 'toMNI', 'MNI2Conform_nonl')
                    candidates_toConform = [base_toConform + ext for ext in ('.nii.gz', '.nii')]
                    inputPath_toConform = next((p for p in candidates_toConform if os.path.exists(p)), None)

                    base_toMNI = os.path.join(m2mDir, 'toMNI', 'Conform2MNI_nonl')
                    candidates_toMNI = [base_toMNI + ext for ext in ('.nii.gz', '.nii')]
                    inputPath_toMNI = next((p for p in candidates_toMNI if os.path.exists(p)), None)

                    if inputPath_toConform is not None and inputPath_toMNI is not None:
                        coordSys = NonlinearTransformedCoordinateSystem(
                            key='MNI_SimNIBSNonlinear',
                            description='SimNIBS-generated nonlinear MNI transform',
                            deformationFieldThisToWorld_filepath=inputPath_toConform,
                            deformationFieldWorldToThis_filepath=inputPath_toMNI,
                            isAutogenerated=True
                        )
                        assert coordSys.key not in self._items
                        self.setItem(coordSys)
                    else:
                        if inputPath_toConform is None:
                            logger.error(f'Did not find expected input file for MNI2Conform_nonl at any of: {candidates_toConform}')
                        if inputPath_toMNI is None:
                            logger.error(f'Did not find expected input file for Conform2MNI_nonl at any of: {candidates_toMNI}')


    def asList(self) -> list[dict[str, tp.Any]]:
        # (don't include auto-generated coord systems since they can be restored separately)
        return [coordSys.asDict() for coordSys in self._items.values() if not coordSys.isAutogenerated]

    @classmethod
    def fromList(cls, coordSysList: list[dict[str, tp.Any]]) -> CoordinateSystems:
        coordinateSystems = {}
        for coordSysDict in coordSysList:
            match coordSysDict['__type']:
                case 'AffineTransformedCoordinateSystem':
                    CoordSysCls = AffineTransformedCoordinateSystem
                case 'NonlinearTransformedCoordinateSystem':
                    CoordSysCls = NonlinearTransformedCoordinateSystem
                case _:
                    raise NotImplementedError("Unexpected CoordinateSystem type: {coordSysDict['__type']}")

            coordinateSystems[coordSysDict['key']] = CoordSysCls.fromDict(coordSysDict)

        return cls(items=coordinateSystems)
